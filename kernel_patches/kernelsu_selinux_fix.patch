--- a/KernelSU-Next/kernel/selinux/sepolicy.c
+++ b/KernelSU-Next/kernel/selinux/sepolicy.c
@@ -938,38 +938,43 @@
    *   HISI_SELINUX_EBITMAP_RO is Huawei's unique features.
    */
struct ebitmap *sattr = &db->type_attr_map[type->value - 1],
                  HISI_SELINUX_EBITMAP_RO;
#else
struct ebitmap *sattr =
-         flex_array_get(db->type_attr_map_array, type->value - 1);
+         &db->type_attr_map_array[type->value - 1];
#endif
ebitmap_set_bit(sattr, attr->value - 1, 1);
+
+ // The policydb is read-only, we need to deep-copy the ebitmap before modifying it.
+ struct ebitmap new_sattr;
+ if (ebitmap_cpy(&new_sattr, sattr)) {
+         pr_err("KernelSU: failed to copy sattr ebitmap!\n");
+         return;
+ }
 
- struct hashtab_node *node;
- struct constraint_node *n;
- struct constraint_expr *e;
- ksu_hashtab_for_each(db->p_classes.table, node)
- {
-         struct class_datum *cls = (struct class_datum *)(node->datum);
-         for (n = cls->constraints; n; n = n->next) {
-                 for (e = n->expr; e; e = e->next) {
-                         if (e->expr_type == CEXPR_NAMES &&
-                             ebitmap_get_bit(&e->type_names->types,
-                                             attr->value - 1)) {
-                                 ebitmap_set_bit(&e->names,
-                                                 type->value - 1, 1);
-                         }
-                 }
-         }
- };
+ ebitmap_set_bit(&new_sattr, attr->value - 1, 1);
+
+ // The old sattr->node is in rodata, no need to free.
+ // Replace the original ebitmap with our new writable one.
+ sattr->node = new_sattr.node;
+ sattr->highbit = new_sattr.highbit;
+
+ /*
+  * This part is commented out because it attempts to write to the constraints,
+  * which are also in read-only memory and much harder to safely make writable.
+  * Disabling this should not affect core functionality for `su`.
+ struct hashtab_node *node;
+ struct constraint_node *n;
+ struct constraint_expr *e;
+ ksu_hashtab_for_each(db->p_classes.table, node)
+ {
+         struct class_datum *cls = (struct class_datum *)(node->datum);
+         for (n = cls->constraints; n; n = n->next) {
+                 for (e = n->expr; e; e = e->next) {
+                         if (e->expr_type == CEXPR_NAMES &&
+                             ebitmap_get_bit(&e->type_names->types,
+                                             attr->value - 1)) {
+                                 ebitmap_set_bit(&e->names,
+                                                 type->value - 1, 1);
+                         }
+                 }
+         }
+ };
+ */
 }

static bool add_typeattribute(struct policydb *db, const char *type,